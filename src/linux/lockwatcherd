#!/usr/bin/python3
'''
lockwatcher.py
@author: Nia Catlin

Runs a group of threads which monitor for potential forensic-related system events
and trigger the antiforensic module if appropriate

Requires 'motion' and 'ifplugd' to be running and properly configured
to use the motion and network connection triggers
'''

import os, sys
import syslog, time, datetime
import threading, queue, struct
import subprocess,multiprocessing
import socket, select
import pyudev 
import imapclient, imaplib
import dbus

from gi.repository import GObject 
from dbus.mainloop.glib import DBusGMainLoop

from lockwatcher import sendemail
from lockwatcher import hardwareconfig
from lockwatcher import AFroutines
from lockwatcher import fileconfig
from lockwatcher import daemon

try:
    import sensors #bastien leonards pysensors
    GOTSENSORS = True
except:
    GOTSENSORS = False

DAEMONPORT = int(fileconfig.config['TRIGGERS']['daemonport'])

eventQueue = queue.Queue()

lockedStateText = {True:'Locked',False:'Not Locked'}
def eventHandle(event_type,eventReason):
    locked = hardwareconfig.checkLock()

    if (event_type in fileconfig.config['TRIGGERS']['ALWAYSTRIGGERS'].split(',')) or \
        (event_type in fileconfig.config['TRIGGERS']['LOCKEDTRIGGERS'].split(',') and locked == True):
        eventQueue.put(("log","[%s - Trigger %s ACTIVATED]: %s"%(lockedStateText[locked],event_type,eventReason)))
        if fileconfig.config['TRIGGERS']['TEST_MODE'] == 'False':
            eventQueue.put(("kill",event_type,eventReason))
        else:
            eventQueue.put(("log",'Shutdown cancelled - test mode active'))
    else:
        if event_type not in ['E_KILL_SWITCH_1','E_KILL_SWITCH_2','E_MOUSE_MV','E_MOUSE_BTN']:
            eventQueue.put(("log","[%s - Trigger %s (ignored)]: %s"%(lockedStateText[locked],event_type,eventReason)))

#handler for pyudev device events
def device_changed(action,device):
    if 'virtual' not in device:
        eventHandle('E_DEVICE',"Device event trigger. Event: %s, Device: %s"%(action,device))
    else:
        #testing on lubuntu had a /sys/devices/virtual/bdi device change happen on screen lock/unlock
        eventQueue.put(("log","Ignoring virtual device change: %s - %s"%(action,device)))
    
#handler for dbus screensaver activity
def scrnLocked(state):
    s = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
    s.connect(('127.0.0.1',DAEMONPORT))
    if state == 1:s.send(b'Locktrue')
    else: s.send(b'Lockfalse')
 
#cannot interact with user screen as root
#make new process to do it as uid of desktop session process
def lockMonitorProcess():
        try:
            os.setuid(fileconfig.DESK_UID)
            session_bus = dbus.SessionBus(mainloop=DBusGMainLoop())
            #subscribe to kde and gnome lock notification signals
            session_bus.add_signal_receiver(scrnLocked,'ActiveChanged','org.freedesktop.ScreenSaver')
            session_bus.add_signal_receiver(scrnLocked,'ActiveChanged','org.gnome.ScreenSaver')
            GObject.MainLoop().run()
        except:
            addLogEntry('Lockwatcher dbus monitor process failed with exception: %s'%str(sys.exc_info()))
    
#gets the exe,arguments of the process 
def getExeCmd(pid):
    cmdPath = '/proc/%s/cmdline'%str(pid)
    try:
        fd = open(cmdPath)
        contents = fd.read()
        fd.close()
    except:
        return None
    
    if len(contents) == 0: return None    
    return contents.split('\x00')

#listens for screensaver notifications on dbus
#Also watches for lock processes stopping/starting for environments
#where dbus notifications are not supported.
lockProgramList = ['kscreenlocker','kscreenlocker_greet','gnome-screensaver-dialog','mate-screensaver-dialog','xlock']
class lockMonitor(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        self.process = None
        self.dbusProcess = None
        self.name = "lockMonThread"
        
        if fileconfig.DESK_UID != None:
            self.dbusProcess = multiprocessing.Process(target=lockMonitorProcess)
            self.dbusProcess.start()
        
        #detect initial lock state by looking for lock processes
        for process in os.listdir('/proc'):
            try:
                pid = int(process)
            except: continue
            cmd = getExeCmd(pid)
            if cmd == None: continue
            if cmd[0] in lockProgramList:
                eventQueue.put(('lock',True))
                break
        else:
            eventQueue.put(('lock',False))
            
    def run(self):
        self.running = True
        lockState = hardwareconfig.checkLock() 
        
        p = subprocess.Popen(['/usr/bin/pgrep', '-xl','xscreensaver'],stdout=subprocess.PIPE)
        output = p.communicate()[0].decode('UTF-8')
        
        #we found xscreensaver running, monitor it for locking
        if 'xscreensaver' in output:
            #might be an idea to reinvent this wheel in python?
            p = subprocess.Popen(['/usr/bin/xscreensaver-command', '-watch'],stdout=subprocess.PIPE)
            self.process = p
            while self.running == True:
                try:
                    output = p.stdout.readline()
                except:
                    if self.running == False: return
                    time.sleep(0.5)
                    p = subprocess.Popen(['/usr/bin/xscreensaver-command', '-watch'],stdout=subprocess.PIPE)
                    self.process = p
                    continue
                
                try:
                    output = output.decode('UTF-8').split(' ')[0]
                except:
                    continue

                if output == 'LOCK': 
                    eventQueue.put(('lock',True))
                    eventQueue.put(('log','Detected xscreensaver locked'))
                elif output == 'UNBLANK':
                    eventQueue.put(('lock',False))
                    eventQueue.put(('log','Detected xscreensaver unlocked'))
                    
        else:
            #other types of screensavers require watching for appearance,vanishing of lock process
            while self.running == True:
                numDirs = os.stat('/proc')[3]
                procList = os.listdir('/proc')
                lockProcessPid = None
                while lockState == False:
                    if self.running == False: break
                    #not too worried about this
                    #timeit.timeit('os.stat("/proc")[3]',setup='import os')
                    newNumDirs = os.stat('/proc')[3]
                    if  newNumDirs == numDirs: 
                        time.sleep(0.5)
                        continue
                    
                    #the rest is probably a lot slower, but at the rate 
                    #processes stop/start it shoudln't matter
                    #a DoS based on mass process creation/termination may be considered though
                    numDirs = newNumDirs
                    newProcList = os.listdir('/proc')
                    newFiles = list(set(newProcList) - set(procList))
                    
                    for file in newFiles:
                        try:
                            lockProcessPid = int(file)
                        except:
                            continue #not a pid
                        
                        cmdLine = getExeCmd(lockProcessPid)
                        if cmdLine == None: continue
                        
                        procName = cmdLine[0].rpartition('/')[2].rstrip(']')
                        
                        #eventQueue.put(('log','process started: '+procName)) #useful for debugging
                        if procName in lockProgramList or ('lightdm' in procName and '-greeter' in procName):
                            lockState = True
                            eventQueue.put(('lock',True))
                            eventQueue.put(('log','Detected screen locked'))
                            break
                        else: continue
                    else:
                        procList = newProcList
                        
                if self.running == False: break
                
                while lockState == True:
                    try:
                        os.kill(lockProcessPid,0)
                        time.sleep(0.5)
                        if self.running == False: break
                        continue
                    except:
                        lockState = False
                        eventQueue.put(('lock',False))

                eventQueue.put(('log','Detected screen Unlocked'))
             
    def stop(self):
        self.running = False
        if self.process != None:
            self.process.kill()
        if self.dbusProcess != None:
            self.dbusProcess.terminate()
        
                            
#waits for events from config programs and the dbus monitor
monitoringRoom = False
class IPCMonitor(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        self.name = "IPCMonThread"
        self.listenSocket = None
        self.lockProcess = None
        
    def run(self):
        try:
            self.listenSocket = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
            self.listenSocket.bind(('127.0.0.1',DAEMONPORT))
        except:
            addLogEntry('Could not bind, closing')
            eventQueue.put(('log','Could not bind to 127.0.0.1:%s, please kill any other lockwatchers and try again'%DAEMONPORT))
            eventQueue.put(('status','ipc','Error: Lockwatcher already running'))
            eventQueue.put(('stop',None))
            
            return
        
        eventQueue.put(('status','ipc','Active'))
        
        self.running = True
        while self.running == True:
            try:
                ready = select.select([self.listenSocket],[],[],120)
                if not ready[0]: continue
            except socket.error:
                if self.running == False: break
                    
                try:
                    s = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
                    s.bind(('127.0.0.1', DAEMONPORT))
                    self.listenSocket = s
                except: pass
                continue
            
            data = self.listenSocket.recv(1024).decode('UTF-8')
            
            if ':' in data: 
                command,value = data.split(':')
            else: 
                command = data
                value = None
            
            if command == 'newListener' and value != None:
                eventQueue.put(('newListener',value))
            elif command == 'getStatuses':
                eventQueue.put(('getStatuses',None))
            elif command == 'startMonitor' or command == 'stopMonitor':
                eventQueue.put((command,value))
            elif command == 'reloadConfig':
                eventQueue.put(('reloadConfig',None))
            elif command == 'stop':
                eventQueue.put(('stop',None))
            elif command == 'Locktrue':
                eventQueue.put(('lock',True))
                eventQueue.put(('log','Detected screen locked'))
            elif command == 'Lockfalse':
                eventQueue.put(('lock',False))
                eventQueue.put(('log','Detected screen unlocked'))
            else:
                eventQueue.put(('log','Bad local command received: %s'%str(command)))
            
        eventQueue.put(('status','ipc','Not Started'))   
                
    def stop(self):
        self.running = False
        try:
            self.listenSocket.shutdown(socket.SHUT_RD)
        except OSError:
            pass #107 endpoint not connected, but socket still gets shutdown so ignore it

#keep asking ifplugstatus how the network interfaces are doing        
#might be good to replicate its functionality instead of requiring+executing it
class netcableMonitor(threading.Thread):
    def __init__(self):  
        threading.Thread.__init__(self)
        self.name = "netadapters"
    def run(self):
        self.running = True
        
        while self.running == True:
            eventQueue.put(('status','netadapters',"Loading Config..."))
            
            monitorUpAdapters = {}
            for iface in fileconfig.config['TRIGGERS']['adapterconids'].split(','):
                monitorUpAdapters[iface] = None
            
            monitorDownAdapters = {}
            for iface in fileconfig.config['TRIGGERS']['adapterdisconids'].split(','):
                monitorDownAdapters[iface] = None
            
            ifplugstatus = '/usr/sbin/ifplugstatus'
            if not os.access(ifplugstatus,os.X_OK):
                ifplugstatus = '/usr/bin/ifplugstatus'
                if not os.access(ifplugstatus,os.X_OK):
                    eventQueue.put(('log','netcableMonitor failed: Cannot find ifplugstatus. Install ifplugd.'))
                    eventQueue.put(('status','netadapters',"Error: ifplugstatus not available"))
                    return
            
            out = subprocess.check_output([ifplugstatus])
            devString = out.decode("utf-8").strip('\n').split('\n')
            for dev in devString:
                devName,devStatus = dev.split(': ')
                if devName in monitorUpAdapters.keys():
                    monitorUpAdapters[devName] = devStatus
                if devName in monitorDownAdapters.keys():
                    monitorDownAdapters[devName] = devStatus
    
            self.listening = True
            eventQueue.put(('status','netadapters',"Active"))
            while self.listening == True:
                time.sleep(1)
                out = subprocess.check_output([ifplugstatus])
                devString = out.decode("utf-8").strip('\n').split('\n')
                for dev in devString:
                    devName,devStatus = dev.split(': ')
                    if devName in monitorUpAdapters.keys():
                        if monitorUpAdapters[devName] != devStatus:
                            if devStatus == 'link beat detected':
                                eventHandle('E_NETCABLE','%s: (%s->%s)'%(devName,monitorUpAdapters[devName],devStatus))
                            monitorUpAdapters[devName] = devStatus
    
                    if devName in monitorDownAdapters.keys():
                        if monitorDownAdapters[devName] != devStatus:
                            if devStatus == 'unplugged':
                                eventHandle('E_NETCABLE','%s: (%s->%s)'%(devName,monitorDownAdapters[devName],devStatus))
                            monitorDownAdapters[devName] = devStatus      
        
        eventQueue.put(('status','netadapters',"Not Started"))     
    
    def reloadConfig(self):
        self.listening = False
            
    def stop(self):
        self.running = False               
        self.listening = False

#lack of access to DIMM SPD data means this only checks motherboard
class temperatureMonitor(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        self.name = "TempMonThread"
        
        if GOTSENSORS == False:
            eventQueue.put(('log',"No pysensors module installed. Could not monitor motherboard temperature."))
            eventQueue.put(('status','temperature',"Error: No pysensors"))
            return
        
        self.running = False
        for chip in sensors.get_detected_chips():
            if "acpi" in str(chip): break
        else:
            eventQueue.put(('log',"Could not read acpi bus: Temperature monitoring disabled"))
            eventQueue.put(('status','temperature',"Error: Could not read ACPI bus"))
            self.die = True
            return
        self.chip = chip
            
        for feature in chip.get_features():
            if 'Temperature' in str(feature): break
        else:
            eventQueue.put(('log',"Could not read temperature from acpi bus: Temperature monitoring disabled"))
            eventQueue.put(('status','temperature',"Error: Could not read temperature from ACPI"))
            return
            
        for subfeature in chip.get_all_subfeatures(feature):
            if 'input' in str(subfeature.name):break
        else: 
            eventQueue.put(('log',"Could not read input from ACPI temperature: Temperature monitoring disabled"))
            eventQueue.put(('status','temperature',"Error: Could not read input temperature from ACPI"))
            return
        
        self.subfeature = subfeature    
        self.running = True
      
    def run(self):
        if self.running == False: return
        
        eventQueue.put(('status','temperature',"Active"))
        while self.running == True:
            time.sleep(1)
            newTemp = self.chip.get_value(self.subfeature.number)
            if newTemp < fileconfig.config['TRIGGERS']['LOW_TEMP']: 
                eventHandle('E_TEMPERATURE',"%s degrees C"%newTemp)
                
        eventQueue.put(('status','temperature',"Not Started"))         
            
    def stop(self):
        self.running = False

#untested
'''
intrusionSwitchPath = '/sys/class/hwmon/hwmon*/device/intrusion0_alarm'
def intrusionSwitchStatus():
    try:
        fd = open(intrusionSwitchPath,'r')
        status = fd.read()
        fd.close()
    except:
        #if it was working when the process started then assume
        #any later problems are due to tampering
        return True 
    return status

#poll the chassis intrusion detection switch for activation
noSwitchNotified = False    
class intrusionMon(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self) 
        self.name = "IntrusionMonThread"

        self.die = False #prevents thread running if there are problems
        global noSwitchNotified 
        if noSwitchNotified == True:
            self.die = True
            return
        
        if not os.path.exists(intrusionSwitchPath) and noSwitchNotified == False:
            eventQueue.put(('log',"Error: No chassis intrusion detection switch found")) 
            noSwitchNotified = True
            self.die = True
            return
        
        #switch already triggered, try to reset it
        if intrusionSwitchStatus() != 0: 
            subprocess.Popen("echo 0 > %s"%intrusionSwitchPath,Shell=True)
            time.sleep(0.5)
            if intrusionSwitchStatus() != 0: 
                eventQueue.put(('log',"Error: Cannot reset an already triggered intrusion switch. Monitoring disabled."))
                self.die = True
                return
                
    def run(self):
        while self.die == False:
            time.sleep(1)
            if intrusionSwitchStatus != 0:
                eventHandle.put(('E_INTRUSION',None))
                
    def stop(self):
        self.die = True
'''                        

#connects to specified bluetooth device, alerts when connection lost   
class bluetoothMon(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self) 
        self.name = "BluetoothMonThread"
        
    def run(self):
        currentlyActive = False
        
        BTDevID = fileconfig.config['TRIGGERS']['BLUETOOTH_DEVICE_ID']
        if BTDevID == '':
            eventQueue.put(('log',"Error: Bluetooth device not configured"))
            eventQueue.put(('status','bluetooth',"Error: Device not configured"))
            return
        
        #if someone needs it then the ability to choose port is there
        if fileconfig.config.has_option('TRIGGERS', 'BLUETOOTH_PORT'):
            bluetoothPort = fileconfig.config['TRIGGERS']['BLUETOOTH_PORT']
        else: bluetoothPort = 2
        
        try:
            self.s = socket.socket(socket.AF_BLUETOOTH, socket.SOCK_STREAM, socket.BTPROTO_RFCOMM)
            self.s.settimeout(50)
            eventQueue.put(('status','bluetooth',"Connecting..."))
            self.s.connect((BTDevID,bluetoothPort))
        except:
            eventQueue.put(('log',"Error: Bluetooth connection to %s unavailable or unauthorised"%BTDevID))
            eventQueue.put(('status','bluetooth',"Error: Connection Failed"))
            return
        
        self.running = True
        while self.running == True:
            
            if currentlyActive == False:
                timeout = 4
            else:
                timeout = 15
            ready = select.select([self.s], [], [],timeout)
                
            if self.running == False: break
            if ready[0] == []: 
                if currentlyActive != True: 
                    eventQueue.put(('status','bluetooth',"Active"))
                    currentlyActive = True
                continue
            
            try:
                self.s.settimeout(10)
                self.s.recv(1024)
            except:
                eventQueue.put(('log',"Bad connection to bluetooth device"))
                if currentlyActive == True:
                    eventQueue.put(('status','bluetooth',"Error: Connection Lost"))
                    currentlyActive = False
                else:
                    eventQueue.put(('status','bluetooth',"Error: Connection Failed"))
                    
                eventHandle('E_BLUETOOTH',None)
                time.sleep(20)

                self.s.close()
                reconnected = False
                while reconnected == False:
                    self.s = socket.socket(socket.AF_BLUETOOTH, socket.SOCK_STREAM, socket.BTPROTO_RFCOMM)
                    self.s.settimeout(20)
                    try:
                        eventQueue.put(('status','bluetooth',"Connecting..."))
                        self.s.connect((fileconfig.config['TRIGGERS']['BLUETOOTH_DEVICE_ID'],bluetoothPort))
                        reconnected = True
                    except:
                        eventQueue.put(('status','bluetooth',"Error: Reconnect Failed"))
                        continue
            
        eventQueue.put(('status','bluetooth',"Not Started"))   
         
    def stop(self):
        self.running = False
        try:
            self.s.shutdown(socket.SHUT_RD)
        except: pass
        self.s.close()

def setupIMAP(config):
    server = imapclient.IMAPClient(config['EMAIL']['EMAIL_IMAP_HOST'], use_uid=False, ssl=True)
    server.login(config['EMAIL']['EMAIL_USERNAME'], fileconfig.config['EMAIL']['EMAIL_PASSWORD'])
    server.select_folder('INBOX')
    eventQueue.put(('log',"Established IMAP connection"))
    return server

#waits for new emails delivered to imap inbox
#puts them in the queue if labelled as sent by expected sender
class emailMonitor(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        self.name = "mailMonThread"
        self.running = True
        
    def run(self):
        eventQueue.put(('status','email',"Connecting to server..."))
        firstAttempt = True
        
        while self.running == True:
            try:
                server = setupIMAP(fileconfig.config)
            except socket.gaierror:
                eventQueue.put(('log',"Error: Could not connect to mail IMAP server, will not listen for remote commands"))
                eventQueue.put(("Status",'email',"Error: IMAP Connection Failed")) 
                if firstAttempt == True: return
            except imapclient.IMAPClient.Error as err:
                eventQueue.put(('log',"Error: Could not connect to mail IMAP server, will not listen for remote commands"))
                eventQueue.put(("Status",'email',err.args[0].decode()))
                if firstAttempt == True: return
            except:
                err = str(sys.exc_info())
                eventQueue.put(('log',"Error: Could not connect to mail IMAP server, will not listen for remote commands: %s"%err))
                eventQueue.put(("Status",'email',"Error: IMAP Connection Failed"))
                if firstAttempt == True: return
            else:
                firstAttempt = False
                
            self.server = server
            self.server.idle()
    
            eventQueue.put(('status','email',"Active"))
            connectionFails = 0
            
            
            
            if self.running == False:
                #user stopped monitor during connection attempt
                eventQueue.put(("Status",'email','Not Started'))
            else: self.listening = True
            
            while self.listening == True:
                #refresh the connection every 14 mins so it doesnt timeout
                try:
                    seqid = self.server.idle_check(480)
                except:
                    if self.running == False: #stop() was called
                        self.listening = False
                        eventQueue.put(("Status",'email','Not Started')) 
                        break
                    
                if seqid == []: #no mail
                    try:
                        '''imapclient gives no way of detecting/handling disconnection
                        just blocks on idle_done until reconnect.
                        Could maybe do this in another thread and give it a time limit but
                        seems harmless enough in testing'''
                        self.server.idle_done()
                        self.server.idle()
                        continue
                    except:
                        print('exception after noop/idle/etc:%s'%str(sys.exc_info()))
                        if self.running == False: break
                        eventQueue.put(('log','IMAP Exception: %s'%str(sys.exc_info())))
                        eventQueue.put(("Status",'email','Attempting reconnect attempt %s'%(connectionFails)))
                        time.sleep(min(1+connectionFails * 3,60))
                        connectionFails += 1
                        ''' #no point really
                        if connectionFails >= 3:
                            eventQueue.put(("Status",'email','Error: Too many failed attempts'))
                            self.listening = False
                            self.running = False
                            break
                        '''
                        break
                
                #fetch header data using the sequence id of the new mail  
                seqid = seqid[0][0]
                server.idle_done()
                keys = server.fetch(seqid, ['ENVELOPE'])
                server.idle()
                
                try:
                    keys = keys[seqid]['ENVELOPE']
                    addressee = keys[2][0][2]
                    intendedAddressee = fileconfig.config['EMAIL']['command_email_address'].split('@')[0]
                    if addressee == intendedAddressee:
                        eventQueue.put(("mail",keys[1]))
                    else:
                        ourAddress = fileconfig.config['EMAIL']['sender_email_address'].split('@')[0]
                        if addressee != ourAddress:
                            eventQueue.put(('log',"Got an email with unknown addressee: %s (need addressee %s)"%
                                            (addressee,intendedAddressee)))
                except:
                    pass #avoid problems when user deletes emails
                
        eventQueue.put(('status','email',"Not Started"))
        
    def stop(self):
        self.running = False
        try:
            self.server.idle_done()
            self.server.logout()
        except:
            pass


#find better way to choose event - /proc/bus/input/devics is good       
class keyboardMonitor(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        self.name = "KeyboardMonThread"
        self.dev = None
        self.pollobject = None
        self.running = False
        
        kbd_device = fileconfig.config['TRIGGERS']['KEYBOARD_DEVICE']
        if kbd_device == 'None' or not os.path.exists(kbd_device):
            kbd_device = hardwareconfig.getKBDDevice()
            if kbd_device == None:
                eventQueue.put(('log',"Keyboard not found"))
                eventQueue.put(('status','killSwitch',"Error: Keyboard not found"))
                return
        
        try:
            self.dev = open(kbd_device,'rb')
        except IOError as e:
            eventQueue.put(('log',"Cannot monitor keyboard: %s\n->Need to run as root"%e))
            eventQueue.put(('status','killSwitch',"Error: No permission to read keyboard device"))
            return
        
        self.running = True
        
    def run(self):
        while self.running == True:
            watchKeys = []
            
            triggerKeys1 = {}
            if 'E_KILL_SWITCH_1' in fileconfig.getActiveTriggers():
                triggerCombo = fileconfig.config['TRIGGERS']['kbd_kill_combo_1'].split('+')
                watchKeys.extend(triggerCombo)
                if len(triggerCombo) == 0: 
                        eventQueue.put(('log',"No trigger key combination provided: keyboard killswitch 1 inactive"))
                else:
                    for key in triggerCombo:
                        triggerKeys1[key] = False    
                            
            triggerKeys2 = {}   
            if 'E_KILL_SWITCH_2' in fileconfig.getActiveTriggers():
                triggerCombo = fileconfig.config['TRIGGERS']['kbd_kill_combo_2'].split('+')
                watchKeys.extend(triggerCombo)
                if len(triggerCombo) == 0: 
                        eventQueue.put(('log',"No trigger key combination provided: keyboard killswitch 2 inactive"))  
                else:
                    for key in triggerCombo:
                        triggerKeys2[key] = False
            
            watchKeys = list(set(watchKeys))
            
            keyEventFormat = 'llHHI'
            keyEventSize = struct.calcsize(keyEventFormat)
            
            #wait for new input on keyboard device
            self.pollobject = select.poll()
            self.pollobject.register(self.dev,select.EPOLLIN)
            eventQueue.put(('status','killSwitch',"Active"))
            
            self.listening = True
            while self.listening == True:
                result = self.pollobject.poll(1000)
                if self.listening == False: break
                if result == []: continue

                event = self.dev.read(keyEventSize)
                (time1, time2, eType, kCode, pressed) = struct.unpack(keyEventFormat, event)
                if eType != 1: continue #if not new key down
                
                kCode = str(kCode)
                if kCode in watchKeys:
                    if pressed == 1:
                        if kCode in triggerKeys1.keys():
                            triggerKeys1[kCode] = True
                            for key,state in triggerKeys1.items():
                                if state == False: break
                            else: eventHandle('E_KILL_SWITCH_1',None)
                            
                        if kCode in triggerKeys2.keys():
                            triggerKeys2[kCode] = True
                            for key,state in triggerKeys2.items():
                                if state == False: break
                            else: eventHandle('E_KILL_SWITCH_2',None)                   
                        
                    elif pressed == 0:
                        if kCode in triggerKeys1.keys(): triggerKeys1[kCode] = False
                        if kCode in triggerKeys2.keys(): triggerKeys2[kCode] = False
                    
        eventQueue.put(('status','killSwitch',"Not Started")) 
        
    def reloadConfig(self):
        self.listening = False
    
    def stop(self):
        self.running = False
        self.listening = False
        self.dev.close()

#BUG: can't read side buttons
#the event readings i am getting make no distinction between the
#press of a side button and a very small mouse movement
#probably hidden in the time values or something?
class mouseMonitor(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        self.name = "MouseMonThread"
        self.pollobject = None
        self.running = False
        
        self.miceDevices = []
        for eventPath in hardwareconfig.getMouseDevices():
            try:
                self.miceDevices.append(open(eventPath,'rb'))
            except:
                continue
        
    def run(self):
        if len(self.miceDevices) == 0:
            eventQueue.put(('log',"Cannot monitor mouse: %s\n->Need to run as root"))
            eventQueue.put(('status','mouse',"Error: Can't read mouse device"))
            return
        
        intFDDict = {}
        for dev in self.miceDevices:
            intFDDict[dev.fileno()] = dev
        
        self.running = True

        mouseEventFormat = 'llHHi'
        mouseEventSize = struct.calcsize(mouseEventFormat)
        
        #wait for new input on keyboard device
        pollobject = select.poll()
        for mouse in self.miceDevices:
            pollobject.register(mouse)
        
        eventQueue.put(('status','mouse',"Active"))
        self.listening = True
        lastTriggerTime = 0
        while self.listening == True:
            result = pollobject.poll(1000)
            if result == []: continue
            
            readFDs = []
            for fd,state in result:
                if state == select.EPOLLOUT: continue #output only
                else: readFDs.append(fd)
            
            if readFDs == []: continue
            
            eventTime = time.time()
            for fd in readFDs:
                try:
                    event = intFDDict[fd].read(mouseEventSize)
                except:
                    if self.listening == False: 
                        break
                    
                if eventTime <  lastTriggerTime+1: continue #read it all out, dont trigger constantly
                (time1, time2, eType, kCode, value) = struct.unpack(mouseEventFormat, event)
                if eType == 0: continue
                if kCode in [8,272,273,274] or value < 0: #mouse 1,2,3 or scroll
                    eventHandle('E_MOUSE_BTN',('Mouse button pressed'))
                    lastTriggerTime = time.time()
                    continue
                
                #wont trigger on tiny movement - considering adding a 
                #'sensitive mode' which will also read side buttons
                if value > 1: 
                    eventHandle('E_MOUSE_MV',('Mouse moved'))
                    lastTriggerTime = time.time()
                    continue
                            
        eventQueue.put(('status','mouse',"Not Started")) 
    
    def stop(self):
        self.running = False
        self.listening = False
        for fd in self.miceDevices:
            fd.close()

#monitor for motion with settings passed to thread
class camera_monitor(threading.Thread):
    def __init__(self,device,settings):
        threading.Thread.__init__(self)
        self.device = device
        self.settings = settings
        self.process = None
        self.event = None
        self.name = "UnnamedCameraMon"
        
    def run(self):
        if self.event == 'E_CHASSIS_MOTION':
            statusName = 'chassis_camera'
        elif self.event == 'E_ROOM_MOTION':
            statusName = 'room_camera'
        else:
            #no reason to get here 
            eventQueue.put(('log',"%s: Error: Camera event not set"%(self.name))) 
            return
        
        eventQueue.put(('status',statusName,"Starting camera...")) 
        
        threshold = self.settings['threshold']
        fps = self.settings['fps']
        minframes = self.settings['minframes']
        savepic = self.settings['savepic']
        
        if os.path.exists("/usr/local/bin/motion-lw"):
            motionPath = "/usr/local/bin/motion-lw"
        elif os.path.exists("/usr/bin/motion-lw"):
            motionPath = "/usr/bin/motion-lw"
        else:
            eventQueue.put(('status',statusName,"Error: Cannot find motion-lw")) 
            eventQueue.put(('log',"%s: Error: Could not find motion-lw in /usr/bin or /usr/local/bin"%self.name))
            return 
            
        args = [motionPath,"-v%s"%self.device,"-t %s"%threshold,"-m %s"%minframes,"-f %s"%fps]
        savePath = fileconfig.config['CAMERAS']['image_path']
        if savepic == True: args.append("-j %s"%savePath)
        
        try:
            monitorproc = subprocess.Popen(args,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
        except:
            eventQueue.put(('status',statusName,"Error: Could not run camera monitor")) 
            eventQueue.put(('log',"%s: Error: Could not run camera monitor: %s"%(self.name,str(sys.exc_info())))) 
            return
        
        if monitorproc == []:
            eventQueue.put(('status',statusName,"Error: Could not run camera monitor")) 
            eventQueue.put(('log',"%s: Error: Could not run camera monitor (2)"%(self.name))) 
            return
        
        self.process = monitorproc
        self.running = True
        eventQueue.put(('status',statusName,"Active"))
        while self.running == True:
            try:
                output = monitorproc.stderr.readline().decode('UTF-8').rstrip().split(':')
            except:
                if self.running == False: break
                eventQueue.put(('status',statusName,"Error: Failed communicating with motion process")) 
                eventQueue.put(('log',"%s: Error: Failed communicating with motion process: %s"%(sys.exc_info()[0]))) 
                return

            if output[0] == 'motion':
                if self.event == 'E_CHASSIS_MOTION' or fileconfig.config['CAMERAS']['room_savepicture'] == 'False':
                    eventHandle(self.event,('Motion detected'))
            elif output[0] == 'path': #a new image capture
                if self.event == 'E_ROOM_MOTION' and fileconfig.config['CAMERAS']['room_savepicture'] == 'True':
                    eventHandle(self.event,('Motion capture generated',output[1]))  
            elif output[0] == '':
                continue
            else: 
                if self.running == False: break
                eventQueue.put(('log',"%s: Motion error for %s: %s"%(self.name,self.device,[output]))) 
                eventQueue.put(('status',statusName,"Error"))
                self.process.kill()
                return
                
        eventQueue.put(('status',statusName,"Not Started"))
                    
    def stop(self):
        self.running = False
        self.process.kill()

REMOTE_LOCK = 1
REMOTE_STARTMONITOR = 2
REMOTE_STOPMONITOR = 3
REMOTE_SHUTDOWN = 4
REMOTE_KILLSWITCH = 5
commandList = range(REMOTE_LOCK,REMOTE_KILLSWITCH+1)
#authenticated email command is passed here for execution
def executeRemoteCommand(command,threadDict):
    config = fileconfig.config
    result = True
    if command == REMOTE_LOCK:
        if hardwareconfig.checkLock() == False:
            AFroutines.lockScreen()
            result = sendemail.sendEmail("Command successful","Screen locked",config)
            eventQueue.put(('log','Locking screen from remote command'))
        else:
            result = sendemail.sendEmail("Command failed","Screen was already locked",config)
            eventQueue.put(('log','Lock screen failed - command received while locked'))
        
    elif command == REMOTE_STARTMONITOR:
        if not isRunning('room_camera',threadDict):
            eventQueue.put(('startMonitor','room_camera'))
            result = sendemail.sendEmail("Command successful","Movement monitoring initiated. Have a nice day.",config)
            eventQueue.put(('log',"Movement monitoring initiated after remote command"))
        else:
            result = sendemail.sendEmail("Command failed","Movement monitoring already active.",config)
            eventQueue.put(('log',"Remote movement monitoring activation failed: already active"))
            
    elif command == REMOTE_STOPMONITOR:
        if isRunning('room_camera',threadDict):
            eventQueue.put(('stopMonitor','room_camera'))
            result = sendemail.sendEmail("Command successful","Movement monitoring disabled. Welcome home!",config)
            eventQueue.put(('log',"Movement monitoring disabled after remote command"))
        else:
            result = sendemail.sendEmail("Command failed","Movement monitoring was not active.",config)
            eventQueue.put(('log',"Remote movement monitoring deactivation failed: not active"))
            
    elif command == REMOTE_SHUTDOWN:
        result = sendemail.sendEmail("Command successful","Shutting down...",config)
        addLogEntry("Standard shutdown due to remote command")
        AFroutines.standardShutdown()
        
    elif command == REMOTE_KILLSWITCH:
        addLogEntry("Emergency shutdown due to remote command")
        AFroutines.emergency()   
    
    if result != True:
        eventQueue.put(('log',"Failed to send email: %s"%str(result)))

def startMonitor(threadDict,monitor):
    if monitor == 'ipc':
        #monitor socket for config program connections
        threadDict['ipc'] = IPCMonitor()
        threadDict['ipc'].start()
        return True
    
    elif monitor == 'lockMon':
        threadDict['lockMon'] = lockMonitor()
        threadDict['lockMon'].start()
        return True
    
    elif monitor == 'killSwitch':
        threadDict['killSwitch'] = keyboardMonitor()
        threadDict['killSwitch'].start()
        return True
    
    elif monitor == 'mouse':
        threadDict['mouse'] = mouseMonitor()
        threadDict['mouse'].start()
        return True
    
    elif monitor == 'chassis_camera':
        deviceName = fileconfig.config['CAMERAS']['cam_chassis']
        cameraDetails = hardwareconfig.getCamNames()
        for dev in cameraDetails:
            if cameraDetails[dev]['ID_MODEL'] == deviceName:
                devicePath = dev
                break
        else:
            eventQueue.put(('status',monitor,"Error: Camera device not found"))
            eventQueue.put(('log',"Camera device %s not found, chassis motion monitoring aborted"%deviceName))
            return False
            
        
        settings = {
        'threshold' : fileconfig.config['CAMERAS']['chassis_threshold'],
        'minframes' : fileconfig.config['CAMERAS']['chassis_minframes'],
        'fps' : fileconfig.config['CAMERAS']['chassis_fps'],
        'savepic' : False
        }
        
        threadDict['chassis_camera'] = camera_monitor(devicePath,settings)
        threadDict['chassis_camera'].name = "chassisCamMon"
        threadDict['chassis_camera'].event = "E_CHASSIS_MOTION"
        threadDict['chassis_camera'].start()
        return True
    
    elif monitor == 'room_camera':
        
        deviceName = fileconfig.config['CAMERAS']['cam_room']
        cameraDetails = hardwareconfig.getCamNames()
        for dev in cameraDetails:
            if cameraDetails[dev]['ID_MODEL'] == deviceName:
                devicePath = dev
                break
        else:
            eventQueue.put(('status',monitor,"Error: Camera device not found"))
            eventQueue.put(('log',"Camera device %s not found, room motion monitoring aborted"%deviceName))
            return False
        
        settings = {
        'threshold' : fileconfig.config['CAMERAS']['room_threshold'],
        'minframes' : fileconfig.config['CAMERAS']['room_minframes'],
        'fps' : fileconfig.config['CAMERAS']['room_fps'],
        }
        if fileconfig.config['CAMERAS']['room_savepicture'] == 'True':
            settings['savepic'] = True
        else: settings['savepic'] = False
        
        threadDict['room_camera'] = camera_monitor(devicePath,settings)
        threadDict['room_camera'].name = "roomCamMon"
        threadDict['room_camera'].event = "E_ROOM_MOTION"
        threadDict['room_camera'].start() 
        return True 
    
    elif monitor == 'bluetooth':
        threadDict['bluetooth'] = bluetoothMon() 
        threadDict['bluetooth'].start()
        return True
    
    elif monitor == 'email':
        threadDict['email'] = emailMonitor()
        threadDict['email'] .start()
        return True
        
    elif monitor == 'devices':
        context = pyudev.Context()
        monitor = pyudev.Monitor.from_netlink(context,source='kernel')
        monitor.start()
        threadDict['devices'] = pyudev.MonitorObserver(monitor, event_handler=device_changed)
        threadDict['devices'].start()
        eventQueue.put(('status','devices',"Active"))
        return True
    
    elif monitor == 'temperature':
        threadDict['temperature'] = temperatureMonitor()
        threadDict['temperature'].start()
        return True
    
    elif monitor == 'netadapters':
        threadDict['netadapters'] = netcableMonitor()
        threadDict['netadapters'].start()
        return True
    
    else: eventQueue.put(('log','Request for unknown monitor start: %s'%str(monitor)))


#send msg to each connection in listeners
def broadcast(listeners,msg):
    badConnections = []
    msg = msg+'@'#message separator

    for connection in listeners:
        try:
            connection.send(msg.encode())
        except: 
            badConnections.append(connection)
    
    for connection in badConnections:
        listeners.remove(connection)

#add msg to log file (or syslog if it isnt usable) + send to all listeners
def addLogEntry(msg,listeners=None):
    entry = time.strftime('[%x %X] ')+msg+'\n'
    logPath = fileconfig.config['TRIGGERS']['logfile']
    try:
        fd = open(logPath,'a+')
        fd.write(entry) 
        fd.close()
    except:
        syslog.syslog(entry)
    
    if listeners != None:
        broadcast(listeners,'Log::'+entry)       

monitorThread = None
def createLockwatcher():
    global monitorThread
    monitorThread = lockwatcher()

def isRunning(threadName,threadDict):
    if threadName in threadDict.keys() and \
        threadDict[threadName] != None and \
            threadDict[threadName].is_alive() == True:
                return True
    else: return False

class lockwatcher(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        self.name = 'Lockwatcher'
        self.running = True
        self.threadDict = {}
        
    def run(self):
        while self.running == True:
            lastStarted = time.time()
            try:
                self.mainloop()
            except:
                addLogEntry('Lockwatcher died with exception: %s. Restarting'%str(sys.exc_info()))
                
                for threadName,thread in self.threadDict.items():
                    if isRunning(threadName,self.threadDict): 
                        thread.stop()
                
                #if we started recently, die to prevent a noisy loop
                if time.time() < lastStarted + 10:
                    addLogEntry('Lockwatcher died after start with exception: %s. Exiting.'%str(sys.exc_info()))
                    self.running = False
                    break

                #otherwise try to restart
                
                lastStarted = time.time()
                time.sleep(1)
            
    def mainloop(self):
        addLogEntry('Initialising lockwatcher')
        global monitoringRoom
        
        listeners = []  #keep active connections to config programs here
        threadDict = {} #keep the running threads here
        self.threadDict = threadDict
        threadStatuses = {} #keep thread statuses here so config programs can have them
        
        startMonitor(threadDict,'ipc')
        startMonitor(threadDict,'lockMon')

        activeTriggers = fileconfig.getActiveTriggers()

        if 'E_KILL_SWITCH_1' in activeTriggers or 'E_KILL_SWITCH_2' in activeTriggers:
            startMonitor(threadDict,'killSwitch')
        
        #run the chassis camera if set to trigger anytime
        if fileconfig.config.has_option('TRIGGERS', 'CHASSIS_LOCK_NONSTOP') and \
            fileconfig['TRIGGERS']['CHASSIS_LOCK_NONSTOP'] == 'True':
                CHASSIS_NONSTOP = True
        else: CHASSIS_NONSTOP = False
        
        if 'E_CHASSIS_MOTION' in fileconfig.config['TRIGGERS']['alwaystriggers']:
            startMonitor(threadDict,'chassis_camera')
        #run it if set to monitor all the time, even if it only triggers when locked
        elif 'E_CHASSIS_MOTION' in fileconfig.config['TRIGGERS']['lockedtriggers'] and CHASSIS_NONSTOP == True:
            startMonitor(threadDict,'chassis_camera')
            
        if 'E_BLUETOOTH 'in activeTriggers:
            startMonitor(threadDict,'bluetooth')

        badCommands = 0
        if fileconfig.config['EMAIL']['enable_remote']=='True':
            startMonitor(threadDict,'email')

        #monitor for device change events from the kernel
        #hopefully intervene before the device can do anything
        if 'E_DEVICE' in activeTriggers: 
            startMonitor(threadDict,'devices')
            
        if 'E_TEMPERATURE' in activeTriggers:
            startMonitor(threadDict,'temperature') 
        
        ''' not tested yet - probably based on a flawed premise
        if 'E_INTRUSION' in fileconfig.config['TRIGGERS']['alwaystriggers']: 
            startMonitor(threadDict,'intrusion') 
        '''
            
        logPath = fileconfig.config['TRIGGERS']['logfile']
        if os.path.exists(logPath):
            creationTime = time.ctime(os.path.getctime(logPath))
            creationMonth = datetime.datetime.strptime(creationTime, "%a %b %d %H:%M:%S %Y")
            creationMonth = "%s %s"%(creationMonth.month,creationMonth.year)
            monthNow = time.strftime('%m %Y')
            if creationMonth != monthNow:
                try:
                    open(logPath, 'w').close()
                    addLogEntry('New log started')
                except: pass
        
        
        eventQueue.put(('log',"Lockwatcher monitoring started"))
        
        shutdownActivated = False
        
        while self.running == True:
            event = eventQueue.get(block=True, timeout=None)
            eventType = event[0]
        
            #--------------trigger activated under shutdown conditions
            if eventType == 'kill':
                eventTrigger = event[1]
                eventDetails = event[2]
                if shutdownActivated == False: 
                    
                    #shutdownActivated = True
                    addLogEntry('Emergency shutdown triggered: %s'%str(eventDetails),listeners)
                    
                    if fileconfig.config['EMAIL']['email_alert'] == 'True':
                        emailResult = True
                        if eventTrigger == 'E_ROOM_MOTION' and \
                            eventDetails[0] == 'Motion capture generated' and fileconfig.config['EMAIL']['EMAIL_MOTION_PICTURE'] == 'True':
                                    picPath = eventDetails[1]
                                    if os.path.exists(picPath):
                                        emailResult = sendemail.sendEmail("Emergency shutdown + Image",str(eventDetails),
                                                                          fileconfig.config,attachment=picPath)
                                
                        else:
                            emailResult = sendemail.sendEmail("Emergency shutdown",str(eventDetails),fileconfig.config)   
                        
                        if emailResult != True:
                            addLogEntry('Failed to send email: %s'%emailResult,listeners)
                        else: addLogEntry('Shutdown alert email sent',listeners)
                                    
                    
                    if eventTrigger == 'E_DEVICE':
                        device = eventDetails.split("'")[1]
                    else: device = None
                    AFroutines.emergency(device)
                    
            #--------------lock state of system changed
            elif eventType == 'lock':
                lockState = event[1]
                hardwareconfig.setLock(lockState)
                
                if lockState == True:
                    if 'E_CHASSIS_MOTION' in fileconfig.config['TRIGGERS']['lockedtriggers'] and \
                    not isRunning('chassis_camera',threadDict):
                        startMonitor(threadDict,'chassis_camera')
                    
                    if 'E_MOUSE_MV' in fileconfig.config['TRIGGERS']['lockedtriggers'] or \
                    'E_MOUSE_BTN' in fileconfig.config['TRIGGERS']['lockedtriggers'] and \
                    not isRunning('mouse',threadDict):  
                        startMonitor(threadDict,'mouse')
                        
                elif lockState == False:
                    if 'E_CHASSIS_MOTION' in fileconfig.config['TRIGGERS']['lockedtriggers'] and \
                        isRunning('chassis_camera',threadDict) and CHASSIS_NONSTOP == False:
                        threadDict['chassis_camera'].stop()
                        threadDict['chassis_camera'] = None
                    
                    if 'E_MOUSE_MV' not in fileconfig.config['TRIGGERS']['alwaystriggers'] and \
                       'E_MOUSE_BTN' not in fileconfig.config['TRIGGERS']['alwaystriggers'] and \
                       isRunning('mouse',threadDict):
                        threadDict['mouse'].stop()
                        threadDict['mouse'] = None  
                        
            #--------------thread status changed, inform any listeners
            elif eventType == 'status':
                threadStatuses[event[1]] = event[2]
                msg = 'Status::%s::%s'%(event[1],event[2])
                broadcast(listeners,msg)
            
            #-----------config programs can request all the current statuses
            elif eventType == 'getStatuses':
                msg = 'AllStatuses::'
                for name,value in threadStatuses.items():
                    msg = msg+ '%s::%s|'%(name,value)
                msg = msg[:-1]
                
                broadcast(listeners,msg)
                
            #--------------add to log file + gui log window if it exists  
            elif eventType.lower() == 'log':
                addLogEntry(str(event[1]),listeners)
            
            #--------------shutdown lockwatcher monitor
            elif eventType == 'stop':
                for thread in threadDict.values():
                    if thread == None: continue
                    try:
                        if thread.is_alive(): thread.stop()
                    except: pass
                addLogEntry('Local stop command received')
                broadcast(listeners,'Shutdown')
                self.running = False
            
            #--------------new mail in imap inbox addressed to us
            elif eventType == 'mail': 
                #malformed emails would be a good way of crashing lockwatcher
                #be careful to valididate mail here
                validMail = True
                try:
                    command, code = event[1].split(' ')
                    eventQueue.put(('log','Received mail "%s %s"'%(command,code)))
                except:
                    validMail = False
                    
                #forgive bad command codes - crappy attack and causes
                #loop if we look at our returned emails with same sender/recv addresss
                if validMail == True:
                    try: 
                        command = int(command)
                        if command not in commandList:
                            continue
                    except:
                        continue
                    
                secret = fileconfig.config['EMAIL']['email_secret']
                if validMail == True and sendemail.validHMAC(code,command,secret) == True:
                    executeRemoteCommand(command, threadDict) 
                    badCommands = 0 #good command resets limit
                else:
                    badCommands += 1
                    sendemail.sendEmail("Command failed","Bad command or authentication code received: %s"%str(event[1]),fileconfig.config)
                    eventQueue.put(('log','Mail not authenticated or bad command: "%s". Ensure clocks are synchronised.'%str(event[1])))
                    badCommandLimit = int(fileconfig.config['EMAIL']['BAD_COMMAND_LIMIT'])
                    if badCommandLimit > 0 and badCommands >= badCommandLimit:
                        addLogEntry(str(event[1]),listeners)
                        
                        if shutdownActivated == False:
                            shutdownActivated = True
                            AFroutines.emergency()
                            
                    continue
            
            #config program wants a monitor started   
            elif eventType == 'startMonitor':
                monitor = event[1]
                if not isRunning(monitor,threadDict):
                    startMonitor(threadDict,monitor)
                else: eventQueue.put(('log','Error starting thread %s: Already running '%monitor))
            
            #config program wants a monitor stopped    
            elif eventType == 'stopMonitor':    
                monitor = event[1]
                if isRunning(monitor,threadDict):
                    threadDict[monitor].stop()
                    if monitor == 'devices': eventQueue.put(('status','devices',"Not Started"))
                else: 
                    eventQueue.put(('log','Failed to stop thread %s: Not Started '%monitor))
            
            #thread has a new status      
            elif eventType == 'Status':
                try:
                    threadStatuses[event[1]] = event[2]
                    msg = 'Status::%s::%s'%(event[1],event[2])
                    broadcast(listeners,msg)
                except:
                    eventQueue.put(('log','Bad status update: %s'%event))
            
            #config program wants all the thread statuses        
            elif eventType == 'getStatuses':
                msg = 'AllStatuses::'
                for name,value in threadStatuses.items():
                    msg = msg+ '%s::%s|'%(name,value)
                msg = msg[:-1]
                
                broadcast(listeners,msg)  
            
            #configuration changed, make threads update their behaviour
            #does not yet apply to everything        
            elif eventType == 'reloadConfig':
                fileconfig.reloadConfig()
                if isRunning('killSwitch',threadDict):  threadDict['killSwitch'].reloadConfig()
                if isRunning('netadapters',threadDict): threadDict['netadapters'].reloadConfig()    
            
            #new config program wants our broadcasts   
            elif eventType == 'newListener':
                port = int(event[1])
                s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
                try:
                    s.connect( ('127.0.0.1', port) )
                except: 
                    eventQueue.put(('log','Error: Failed to connect to client port: '+str(port)))
                    continue
                
                eventQueue.put(('log','Lockwatcher connected to new configuration client'))
                s.send(b'True@')
                listeners.append(s)      
                  
            else:
                eventQueue.put(('log','Unknown event %s on event queue'%[event]))

monitorThread = None

class lockWatcherDaemon(daemon.daemon): 
    lwThread = None
    def run(self):
        lwThread = lockwatcher()  
        lwThread.start()
        
    def stop(self):
        s = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
        try:
            s.connect(('127.0.0.1', DAEMONPORT))
        except:
            return
        s.send(b'stop')
        s.close()

if __name__ == "__main__":
        if len(sys.argv) == 2:
 
                lwdaemon = lockWatcherDaemon('/var/run/lockwatcher.pid')
                if 'start' == sys.argv[1]:
                        if os.geteuid() != 0:
                            print("Run this as root/sudo root")
                            exit()
                        try:
                            listenSocket = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
                            listenSocket.bind(('127.0.0.1',DAEMONPORT))
                            listenSocket.close()
                        except:
                            print('Could not bind to 127.0.0.1:%s. Lockwatcher already running?'%str(DAEMONPORT))
                            exit()
                        
                        print('Starting lockwatcher...')
                        lwdaemon.start()
                elif 'stop' == sys.argv[1]:
                        lwdaemon.stop()
                elif 'restart' == sys.argv[1]:
                        lwdaemon.restart()
                else:
                        print("Unknown command %s"%str(sys.argv[1]))
                        print( "usage: %s start|stop|restart" % sys.argv[0])
                        sys.exit(2)
                sys.exit(0)
        else:
                print( "usage: %s start|stop|restart" % sys.argv[0])
                sys.exit(2)  